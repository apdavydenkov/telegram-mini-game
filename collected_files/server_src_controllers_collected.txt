// Собранный код для папки server_src_controllers

// Код файла controllers\authController.js:
const User = require('../models/User');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

exports.register = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    // Проверяем, существует ли уже пользователь с таким именем или email
    const existingUser = await User.findOne({ $or: [{ username }, { email }] });
    if (existingUser) {
      console.log('Регистрация не удалась: Пользователь уже существует');
      return res.status(400).json({ message: 'Пользователь уже существует' });
    }
    
    // Хешируем пароль
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
    
    // Создаем нового пользователя
    const newUser = new User({
      username,
      email,
      password: hashedPassword,
      hasCharacter: false
    });
    
    await newUser.save();
    console.log('Создан новый пользователь:', newUser._id);
    
    // Генерируем токен
    const token = jwt.sign({ id: newUser._id }, process.env.JWT_SECRET, { expiresIn: '1h' });
    console.log('Токен сгенерирован для нового пользователя');
    
    res.status(201).json({ 
      message: 'Пользователь успешно зарегистрирован', 
      token,
      user: {
        id: newUser._id,
        username: newUser.username,
        email: newUser.email,
        hasCharacter: newUser.hasCharacter
      }
    });
  } catch (error) {
    console.error('Ошибка регистрации:', error);
    res.status(500).json({ message: 'Ошибка сервера', error: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Ищем пользователя
    const user = await User.findOne({ username });
    if (!user) {
      console.log('Вход не удался: Пользователь не найден');
      return res.status(400).json({ message: 'Неверные учетные данные' });
    }
    
    // Проверяем пароль
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      console.log('Вход не удался: Неверный пароль');
      return res.status(400).json({ message: 'Неверные учетные данные' });
    }
    
    // Генерируем токен
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1h' });
    console.log('Вход успешен, токен сгенерирован');
    
    res.json({ 
      token,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role,
        hasCharacter: user.hasCharacter
      }
    });
  } catch (error) {
    res.status(400).json({ message: 'Error logging in', error: error.message });
  }
};

exports.getCurrentUser = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    res.json({
      id: user._id,
      username: user.username,
      email: user.email,
      role: user.role,
      hasCharacter: user.hasCharacter
    });
  } catch (error) {
    console.error('Ошибка при получении данных пользователя:', error);
    res.status(500).json({ message: 'Ошибка сервера', error: error.message });
  }
};

exports.makeAdmin = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    user.role = 'admin';
    await user.save();
    
    res.json({
      message: 'User role updated to admin',
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role,
        hasCharacter: user.hasCharacter
      }
    });
  } catch (error) {
    console.error('Error updating user role:', error);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

// Код файла controllers\characterController.js:
const Character = require('../models/Character');
const User = require('../models/User');
const GameItem = require('../models/GameItem');
const CharItem = require('../models/CharItem');

exports.createCharacter = async (req, res) => {
  try {
    const { nickname, class: characterClass, baseStrength, baseDexterity, baseIntelligence, baseEndurance, baseCharisma } = req.body;
    
    // Проверка распределения очков
    const baseStats = 50; // 10 на каждую характеристику
    const totalStats = baseStrength + baseDexterity + baseIntelligence + baseEndurance + baseCharisma;
    if (totalStats - baseStats > 5) {
      return res.status(400).json({ message: 'Неверное распределение характеристик' });
    }

    // Проверяем, есть ли уже персонаж у пользователя
    const existingCharacter = await Character.findOne({ user: req.user._id });
    if (existingCharacter) {
      return res.status(400).json({ message: 'У пользователя уже есть персонаж' });
    }

    const character = new Character({
      user: req.user._id,
      nickname,
      class: characterClass,
      baseStrength,
      baseDexterity,
      baseIntelligence,
      baseEndurance,
      baseCharisma,
      availablePoints: 5 - (totalStats - baseStats)
    });

    await character.save();

    // Обновляем поле hasCharacter у пользователя
    await User.findByIdAndUpdate(req.user._id, { hasCharacter: true });

    // Получаем данные о здоровье и рассчитываем характеристики
    const healthData = character.getHealthData();
    const calculatedStats = character.getStatsData();

    // Добавляем healthData и calculatedStats к ответу
    const characterData = character.toObject();
    characterData.healthData = healthData;
    characterData.calculatedStats = calculatedStats;

    res.status(201).json(characterData);
  } catch (error) {
    console.error('Ошибка создания персонажа:', error);
    res.status(400).json({ message: 'Ошибка создания персонажа', error: error.message });
  }
};

exports.getCharacter = async (req, res) => {
  try {
    const character = await Character.findOne({ user: req.user._id })
      .populate({
        path: 'inventory',
        populate: { path: 'gameItem' }
      });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }
    
    const healthData = character.getHealthData();
    const calculatedStats = character.getStatsData();
    const characterData = character.toObject();
    characterData.healthData = healthData;
    characterData.calculatedStats = calculatedStats;
    
    res.json(characterData);
  } catch (error) {
    console.error('Ошибка при получении персонажа:', error);
    res.status(400).json({ message: 'Ошибка при получении персонажа', error: error.message });
  }
};

exports.updateCharacter = async (req, res) => {
  try {
    const { baseStrength, baseDexterity, baseIntelligence, baseEndurance, baseCharisma, version } = req.body;
    
    const character = await Character.findOne({ user: req.user._id })
      .populate({
        path: 'inventory',
        populate: { path: 'gameItem' }
      });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    if (character.version !== version) {
      return res.status(409).json({ message: 'Конфликт версий. Обновите данные и попробуйте снова.' });
    }

    if (character.zeroPoints) {
      return res.status(400).json({ message: 'Распределение очков уже завершено' });
    }

    const newTotalStats = baseStrength + baseDexterity + baseIntelligence + baseEndurance + baseCharisma;
    const oldTotalStats = character.baseStrength + character.baseDexterity + character.baseIntelligence + character.baseEndurance + character.baseCharisma;
    const pointsSpent = newTotalStats - oldTotalStats;

    if (pointsSpent > character.availablePoints || pointsSpent < 0) {
      return res.status(400).json({ message: 'Недопустимое распределение очков' });
    }

    character.baseStrength = baseStrength;
    character.baseDexterity = baseDexterity;
    character.baseIntelligence = baseIntelligence;
    character.baseEndurance = baseEndurance;
    character.baseCharisma = baseCharisma;
    character.availablePoints -= pointsSpent;

    // Здоровье обновится автоматически в pre-save хуке
    await character.save();
    
    const healthData = character.getHealthData();
    const calculatedStats = character.getStatsData();
    const characterData = character.toObject();
    characterData.healthData = healthData;
    characterData.calculatedStats = calculatedStats;

    res.json(characterData);
  } catch (error) {
    console.error('Ошибка обновления персонажа:', error);
    res.status(400).json({ message: 'Ошибка обновления персонажа', error: error.message });
  }
};

exports.equipCharItem = async (req, res) => {
  try {
    const { charItemId } = req.body;
    const character = await Character.findOne({ user: req.user._id }).populate({
      path: 'inventory',
      populate: { path: 'gameItem' }
    });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    const charItemToEquip = character.inventory.find(charItem => charItem._id.toString() === charItemId);
    if (!charItemToEquip || !charItemToEquip.gameItem) {
      return res.status(404).json({ message: 'Предмет не найден в инвентаре или не содержит данных gameItem' });
    }

    const gameItemType = charItemToEquip.gameItem.type;

    // Если предмет уже экипирован, снимаем его
    if (charItemToEquip.isEquipped) {
      charItemToEquip.isEquipped = false;
      charItemToEquip.slot = null;
    } else {
      // Логика для расходуемых предметов
      if (gameItemType === 'useful') {
        const usefulSlots = ['useful1', 'useful2', 'useful3'];
        const emptySlot = usefulSlots.find(slot => 
          !character.inventory.some(charItem => charItem.isEquipped && charItem.slot === slot)
        );
        
        if (emptySlot) {
          charItemToEquip.slot = emptySlot;
        } else {
          // Если все слоты заняты, заменяем предмет в третьем слоте
          const charItemInThirdSlot = character.inventory.find(charItem => charItem.isEquipped && charItem.slot === 'useful3');
          if (charItemInThirdSlot) {
            charItemInThirdSlot.isEquipped = false;
            charItemInThirdSlot.slot = null;
            await charItemInThirdSlot.save();
          }
          charItemToEquip.slot = 'useful3';
        }
      } else {
        // Для остальных типов предметов логика остается прежней
        const equippedCharItem = character.inventory.find(charItem => 
          charItem.isEquipped && charItem.gameItem && charItem.gameItem.type === gameItemType
        );
        if (equippedCharItem) {
          equippedCharItem.isEquipped = false;
          equippedCharItem.slot = null;
          await equippedCharItem.save();
        }
        charItemToEquip.slot = gameItemType;
      }
      
      charItemToEquip.isEquipped = true;
    }

    await charItemToEquip.save();
    await character.save();

    const updatedCharacter = await Character.findOne({ user: req.user._id }).populate({
      path: 'inventory',
      populate: { path: 'gameItem' }
    });
    const healthData = updatedCharacter.getHealthData();
    const calculatedStats = updatedCharacter.getStatsData();
    const characterData = updatedCharacter.toObject();
    characterData.healthData = healthData;
    characterData.calculatedStats = calculatedStats;

    res.json(characterData);
  } catch (error) {
    console.error('Ошибка экипировки предмета:', error);
    res.status(400).json({ message: 'Ошибка экипировки предмета', error: error.message });
  }
};

exports.addItemToInventory = async (req, res) => {
  try {
    const { gameItemId, quantity = 1 } = req.body;
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    const gameItem = await GameItem.findById(gameItemId);
    if (!gameItem) {
      return res.status(404).json({ message: 'Игровой предмет не найден' });
    }

    let charItem = await CharItem.findOne({ character: character._id, gameItem: gameItemId, isEquipped: false });
    if (charItem) {
      charItem.quantity += quantity;
    } else {
      charItem = new CharItem({
        character: character._id,
        gameItem: gameItemId,
        quantity
      });
    }

    await charItem.save();
    character.inventory.push(charItem._id);
    await character.save();

    const updatedCharacter = await Character.findOne({ user: req.user._id }).populate({
      path: 'inventory',
      populate: { path: 'gameItem' }
    });
    const healthData = updatedCharacter.getHealthData();
    const calculatedStats = updatedCharacter.getStatsData();
    const characterData = updatedCharacter.toObject();
    characterData.healthData = healthData;
    characterData.calculatedStats = calculatedStats;

    res.json(characterData);
  } catch (error) {
    console.error('Ошибка добавления предмета в инвентарь:', error);
    res.status(400).json({ message: 'Ошибка добавления предмета в инвентарь', error: error.message });
  }
};

exports.getHealthData = async (req, res) => {
  try {
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    const healthData = character.getHealthData();
    res.json(healthData);
  } catch (error) {
    console.error('Ошибка при получении данных о здоровье:', error);
    res.status(400).json({ message: 'Ошибка при получении данных о здоровье', error: error.message });
  }
};

exports.damageCharacter = async (req, res) => {
  try {
    const { damage } = req.body;
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    const currentHealth = character.getCurrentHealth();
    const newHealth = Math.max(0, currentHealth - damage);
    character.updateHealth(newHealth);

    await character.save();

    const healthData = character.getHealthData();
    res.json(healthData);
  } catch (error) {
    console.error('Ошибка при нанесении урона персонажу:', error);
    res.status(400).json({ message: 'Ошибка при нанесении урона персонажу', error: error.message });
  }
};

module.exports = exports;

// Код файла controllers\charItemController.js:
const CharItem = require('../models/CharItem');
const Character = require('../models/Character');
const GameItem = require('../models/GameItem');

exports.createCharItem = async (req, res) => {
  try {
    const { gameItemId, characterId, quantity } = req.body;
    
    const character = await Character.findById(characterId);
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    const gameItem = await GameItem.findById(gameItemId);
    if (!gameItem) {
      return res.status(404).json({ message: 'Игровой предмет не найден' });
    }

    const charItem = new CharItem({
      gameItem: gameItemId,
      character: characterId,
      quantity: quantity || 1
    });

    await charItem.save();
    character.inventory.push(charItem._id);
    await character.save();

    res.status(201).json(charItem);
  } catch (error) {
    res.status(400).json({ message: 'Ошибка создания предмета персонажа', error: error.message });
  }
};

exports.getCharItemById = async (req, res) => {
  try {
    const charItem = await CharItem.findById(req.params.id).populate('gameItem');
    if (!charItem) {
      return res.status(404).json({ message: 'Предмет не найден' });
    }
    res.json(charItem);
  } catch (error) {
    res.status(400).json({ message: 'Ошибка получения предмета', error: error.message });
  }
};

exports.updateCharItem = async (req, res) => {
  try {
    const { quantity, isEquipped, slot } = req.body;
    const charItem = await CharItem.findById(req.params.id);
    
    if (!charItem) {
      return res.status(404).json({ message: 'Предмет не найден' });
    }

    if (quantity !== undefined) charItem.quantity = quantity;
    if (isEquipped !== undefined) charItem.isEquipped = isEquipped;
    if (slot !== undefined) charItem.slot = slot;

    await charItem.save();
    res.json(charItem);
  } catch (error) {
    res.status(400).json({ message: 'Ошибка обновления предмета', error: error.message });
  }
};

exports.deleteCharItem = async (req, res) => {
  try {
    const charItem = await CharItem.findById(req.params.id);
    if (!charItem) {
      return res.status(404).json({ message: 'Предмет не найден' });
    }

    const character = await Character.findById(charItem.character);
    if (character) {
      character.inventory = character.inventory.filter(item => item.toString() !== charItem._id.toString());
      await character.save();
    }

    await CharItem.findByIdAndDelete(req.params.id);
    res.json({ message: 'Предмет успешно удален' });
  } catch (error) {
    res.status(400).json({ message: 'Ошибка удаления предмета', error: error.message });
  }
};

module.exports = exports;

// Код файла controllers\combatController.js:
 


// Код файла controllers\gameItemController.js:
const GameItem = require('../models/gameItem');
const Character = require('../models/Character');
const CharItem = require('../models/CharItem');
const mongoose = require('mongoose');

exports.createGameItem = async (req, res) => {
  try {
    const gameItem = new GameItem(req.body);
    await gameItem.save();
    res.status(201).json(gameItem);
  } catch (error) {
    res.status(400).json({ message: 'Error creating game item', error: error.message });
  }
};

exports.getAllGameItems = async (req, res) => {
  try {
    const gameItems = await GameItem.find();
    res.json(gameItems);
  } catch (error) {
    res.status(400).json({ message: 'Error fetching game items', error: error.message });
  }
};

exports.getGameItemById = async (req, res) => {
  try {
    const gameItem = await GameItem.findById(req.params.id);
    if (!gameItem) {
      return res.status(404).json({ message: 'Game item not found' });
    }
    res.json(gameItem);
  } catch (error) {
    res.status(400).json({ message: 'Error fetching game item', error: error.message });
  }
};

exports.updateGameItem = async (req, res) => {
  try {
    const gameItem = await GameItem.findByIdAndUpdate(req.params.id, req.body, { new: true });
    if (!gameItem) {
      return res.status(404).json({ message: 'Game item not found' });
    }
    res.json(gameItem);
  } catch (error) {
    res.status(400).json({ message: 'Error updating game item', error: error.message });
  }
};

exports.deleteGameItem = async (req, res) => {
  try {
    const gameItem = await GameItem.findByIdAndDelete(req.params.id);
    if (!gameItem) {
      return res.status(404).json({ message: 'Game item not found' });
    }
    res.json({ message: 'Game item deleted successfully' });
  } catch (error) {
    res.status(400).json({ message: 'Error deleting game item', error: error.message });
  }
};

exports.sendGameItem = async (req, res) => {
  try {
    const { gameItemId, characterId } = req.params;

    const gameItem = await GameItem.findById(gameItemId);
    if (!gameItem) {
      return res.status(404).json({ message: 'Game item not found' });
    }
    
    const character = await Character.findById(characterId);
    if (!character) {
      return res.status(404).json({ message: 'Character not found' });
    }
    
    // Создаем новый CharItem
    const charItem = new CharItem({
      gameItem: gameItem._id,
      character: character._id,
      quantity: 1,
      isEquipped: false,
      slot: null
    });

    await charItem.save();
    
    // Добавляем CharItem к инвентарю персонажа
    character.inventory.push(charItem._id);
    await character.save();
    
    res.json({ message: 'Game item sent to character successfully', character });
  } catch (error) {
    console.error('Error sending game item:', error);
    res.status(400).json({ message: 'Error sending game item', error: error.message });
  }
};

module.exports = exports;

// Код файла controllers\inventoryController.js:
 


// Код файла controllers\skillController.js:
 

