// Собранный код для папки server_src_models

// Код файла models\Character.js:
const mongoose = require('mongoose');

const characterSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  nickname: {
    type: String,
    required: true
  },
  class: {
    type: String,
    enum: ['Warrior', 'Mage', 'Archer'],
    required: true
  },
  level: { type: Number, default: 1 },
  experience: { type: Number, default: 0 },
  gold: { type: Number, default: 0 },
  status: {
    type: String,
    enum: ['idle', 'in_battle', 'resting'],
    default: 'idle'
  },

  // Базовые характеристики
  baseStrength: { type: Number, default: 10 },
  baseDexterity: { type: Number, default: 10 },
  baseIntelligence: { type: Number, default: 10 },
  baseEndurance: { type: Number, default: 10 },
  baseCharisma: { type: Number, default: 10 },

  // Здоровье
  health: {
    type: Number,
    default: function () {
      return this.getMaxHealth();
    }
  },

  lastHealthUpdate: { type: Date, default: Date.now },
  fullRegenTime: { type: Number, default: 60 }, // значение в секундах

  // Очки характеристик
  availablePoints: { type: Number, default: 5 },

  // Инвентарь
  inventory: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'CharItem'
  }],

  version: { type: Number, default: 0 }
}, { timestamps: true });

// Виртуальное поле для проверки завершения распределения очков
characterSchema.virtual('zeroPoints').get(function () {
  return this.availablePoints === 0;
});

// Виртуальное поле для максимального здоровья
characterSchema.virtual('maxHealth').get(function () {
  return this.getMaxHealth();
});

// Виртуальное поле для скорости регенерации здоровья
characterSchema.virtual('healthRegenRate').get(function () {
  return this.getHealthRegenRate();
});

// Метод для получения максимального здоровья
characterSchema.methods.getMaxHealth = function () {
  const healthPerEndurance = 5;
  const baseHealth = 100 * this.level;

  // Расчет бонусов за экипированные предметы
  const { enduranceBonus, healthBonus } = this.inventory
    .filter(charItem => charItem.isEquipped && charItem.gameItem && charItem.gameItem.stats)
    .reduce((acc, charItem) => {
      acc.enduranceBonus += charItem.gameItem.stats.endurance || 0;
      acc.healthBonus += charItem.gameItem.stats.health || 0;
      return acc;
    }, { enduranceBonus: 0, healthBonus: 0 });

  // Общий и бонус за выносливость
  const totalEnduranceBonus = (this.baseEndurance + enduranceBonus) * healthPerEndurance;

  // Итоговое максимальное здоровье
  return Math.round(baseHealth + totalEnduranceBonus + healthBonus);
};

// Метод для получения скорости регенерации здоровья
characterSchema.methods.getHealthRegenRate = function () {
  const maxHealth = this.getMaxHealth();
  return maxHealth / this.fullRegenTime;
};

// Метод для получения текущего здоровья с учетом регенерации
characterSchema.methods.getCurrentHealth = function () {
  const now = new Date();
  const healthRegenDuration = Math.max(0, (now - this.lastHealthUpdate) / 1000);
  const healthRegenRate = this.getHealthRegenRate();
  const healthRegenAmount = healthRegenRate * healthRegenDuration;
  const maxHealth = this.getMaxHealth();
  const newHealth = Math.min(this.health + healthRegenAmount, maxHealth);

  return Math.round(newHealth);
};

// Метод для обновления здоровья на текущее
characterSchema.methods.updateHealth = function (newHealth) {
  this.health = this.getCurrentHealth();
  this.lastHealthUpdate = new Date();
};

// Метод для получения текущих данных о здоровье
characterSchema.methods.getHealthData = function () {
  return {
    currentHealth:this.getCurrentHealth(),
    maxHealth:this.getMaxHealth(),
    healthRegenRate:this.getHealthRegenRate(),
    lastHealthUpdate:this.lastHealthUpdate
  };
};

// Метод для пересчета всех характеристик
characterSchema.methods.getStatsData = function () {
  const equippedCharItems = this.inventory.filter(charItem => charItem.isEquipped && charItem.gameItem);

  const baseStats = {
    strength: this.baseStrength,
    dexterity: this.baseDexterity,
    intelligence: this.baseIntelligence,
    endurance: this.baseEndurance,
    charisma: this.baseCharisma
  };

  equippedCharItems.forEach(charItem => {
    if (charItem.gameItem && charItem.gameItem.stats) {
      Object.keys(charItem.gameItem.stats).forEach(stat => {
        if (baseStats.hasOwnProperty(stat)) {
          baseStats[stat] += charItem.gameItem.stats[stat];
        }
      });
    }
  });

  // Формулы расчёта боевых характеристик
  return {
    ...baseStats,
    health: this.getCurrentHealth(),
    maxHealth: this.getMaxHealth(),
    healthRegenRate: parseFloat(this.getHealthRegenRate().toFixed(2)),
    damage: Math.round(baseStats.strength * 1.5 + baseStats.intelligence * 0.5),
    armor: Math.round(baseStats.endurance * 0.5),
    criticalChance: parseFloat((baseStats.intelligence * 0.2).toFixed(2)),
    criticalDamage: Math.round(100 + baseStats.intelligence * 2),
    dodge: parseFloat((baseStats.dexterity * 0.3).toFixed(2)),
    counterAttack: parseFloat((baseStats.dexterity * 0.2 + baseStats.charisma * 0.1).toFixed(2)),
  };
};

// Метод для обновления здоровья после экипировки/снятия предмета или изменения характеристик
characterSchema.methods.updateHealthAfterChange = function (oldMaxHealth) {
  const newMaxHealth = this.getMaxHealth();
  const currentHealth = this.getCurrentHealth();

  if (newMaxHealth !== oldMaxHealth) {
    const healthRatio = currentHealth / oldMaxHealth;
    this.health = Math.min(currentHealth, Math.round(newMaxHealth * healthRatio));
  } else {
    this.health = currentHealth;
  }

  this.lastHealthUpdate = new Date();
};

// Пре-сохранение для увеличения версии и обновления здоровья
characterSchema.pre('save', function (next) {
  if (this.isNew) {
    this.health = this.getMaxHealth();
  } else {
    const oldMaxHealth = this.getMaxHealth();
    this.updateHealthAfterChange(oldMaxHealth);
  }

  if (this.isModified('baseStrength') ||
    this.isModified('baseDexterity') ||
    this.isModified('baseIntelligence') ||
    this.isModified('baseEndurance') ||
    this.isModified('baseCharisma') ||
    this.isModified('inventory')) {
    this.version += 1;
  }

  next();
});

module.exports = mongoose.model('Character', characterSchema);

// Код файла models\CharItem.js:
const mongoose = require('mongoose');

const charItemSchema = new mongoose.Schema({
  gameItem: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'GameItem', 
    required: true 
  },
  character: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Character', 
    required: true 
  },
  quantity: { 
    type: Number, 
    default: 1 
  },
  isEquipped: { 
    type: Boolean, 
    default: false 
  },
  slot: { 
    type: String, 
    enum: ['weapon', 'armor', 'helmet', 'shield', 'cloak', 'boots', 'belt', 'banner', 'useful1', 'useful2', 'useful3', null],
    default: null
  }
}, { timestamps: true });

// Метод для экипировки предмета
charItemSchema.methods.setEquippedStatus = function(isEquipped) {
  this.isEquipped = isEquipped;
  if (!isEquipped) {
    this.slot = null;
  }
  return this.save();
};

module.exports = mongoose.model('CharItem', charItemSchema);  

// Код файла models\Combat.js:
 


// Код файла models\GameItem.js:
const mongoose = require('mongoose');

const gameItemSchema = new mongoose.Schema({
  name: { type: String, required: true },
  type: { 
    type: String, 
    enum: ['weapon', 'armor', 'banner', 'helmet', 'shield', 'cloak', 'belt', 'boots', 'useful'], 
    required: true 
  },
  rarity: {
    type: String,
    enum: ['common', 'uncommon', 'rare', 'epic', 'legendary'],
    default: 'common'
  },
  minLevel: { type: Number, default: 1 },
  image: { type: String, default: '' },
  stats: {
    strength: { type: Number, default: 0 },
    dexterity: { type: Number, default: 0 },
    intelligence: { type: Number, default: 0 },
    endurance: { type: Number, default: 0 },
    charisma: { type: Number, default: 0 },
    damage: { type: Number, default: 0 },
    armor: { type: Number, default: 0 },
    criticalChance: { type: Number, default: 0 },
    criticalDamage: { type: Number, default: 0 },
    dodge: { type: Number, default: 0 },
    counterAttack: { type: Number, default: 0 },
    health: { type: Number, default: 0 },
    healthRegenRate: { type: Number, default: 0 }
  }
});

module.exports = mongoose.models.GameItem || mongoose.model('GameItem', gameItemSchema);

// Код файла models\Skill.js:
 


// Код файла models\User.js:
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: { 
    type: String, 
    required: true, 
    unique: true 
  },
  email: { 
    type: String, 
    required: true, 
    unique: true 
  },
  password: { 
    type: String, 
    required: true 
  },
  role: {
    type: String,
    enum: ['player', 'moderator', 'admin'],
    default: 'player'
  },
  hasCharacter: { 
    type: Boolean, 
    default: false 
  }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);
