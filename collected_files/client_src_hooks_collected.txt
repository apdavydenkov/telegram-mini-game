// Собранный код для папки client_src_hooks

// Код файла hooks\useAuth.js:
import { useState, useEffect, useCallback } from 'react';
import { auth } from '../services/api';
import { useNavigate } from 'react-router-dom';

const useAuth = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  const loadUser = useCallback(async () => {
    try {
      const { data } = await auth.getCurrentUser();
      setUser(data);
    } catch (error) {
      console.error('Error loading user:', error);
      setUser(null);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadUser();
  }, [loadUser]);

  const login = async (username, password) => {
    try {
      const { data } = await auth.login(username, password);
      localStorage.setItem('token', data.token);
      setUser(data.user);
      navigate('/dashboard');
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  };

  const register = async (username, email, password) => {
    try {
      const { data } = await auth.register(username, email, password);
      localStorage.setItem('token', data.token);
      setUser(data.user);
      navigate('/dashboard');
    } catch (error) {
      console.error('Registration error:', error);
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
    navigate('/login');
  };

  return { user, loading, login, register, logout };
};

export default useAuth;

// Код файла hooks\useCharacter.js:
import { useState, useEffect, useCallback, useRef } from 'react';
import { character } from '../services/api';

const useCharacter = () => {
  const [characterData, setCharacterData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isUpdating, setIsUpdating] = useState(false);
  const healthUpdateInterval = useRef(null);
  const updateTimeoutRef = useRef(null);

  const calculateMaxHealth = useCallback((char) => {
    if (!char) return 0;
    const baseHealth = 100 * char.level;
    const enduranceBonus = char.baseEndurance * 5;
    const equipmentBonus = char.inventory
      .filter(item => item.isEquipped && item.gameItem)
      .reduce((sum, item) => {
        return sum + (item.gameItem.stats.endurance || 0) * 5 + (item.gameItem.stats.health || 0);
      }, 0);
    return baseHealth + enduranceBonus + equipmentBonus;
  }, []);

  const updateHealth = useCallback(() => {
    if (!characterData) return;

    const now = new Date();
    const healthRegenDuration = Math.max(0, (now - new Date(characterData.healthData.lastHealthUpdate)) / 1000);
    const healthRegenAmount = characterData.calculatedStats.healthRegenRate * healthRegenDuration;
    const newHealth = Math.min(
      characterData.healthData.currentHealth + healthRegenAmount,
      characterData.healthData.maxHealth
    );

    setCharacterData(prevData => ({
      ...prevData,
      healthData: {
        ...prevData.healthData,
        currentHealth: Math.round(newHealth * 100) / 100,
        lastHealthUpdate: now.toISOString()
      }
    }));
  }, [characterData]);

  const fetchCharacter = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const { data } = await character.get();
      const maxHealth = calculateMaxHealth(data);
      setCharacterData({
        ...data,
        healthData: {
          currentHealth: data.healthData.currentHealth,
          maxHealth: maxHealth,
          lastHealthUpdate: new Date().toISOString()
        },
        calculatedStats: {
          ...data.calculatedStats,
          healthRegenRate: maxHealth / data.fullRegenTime
        }
      });
    } catch (err) {
      console.error('Error fetching character:', err);
      setError('Failed to load character data');
    } finally {
      setLoading(false);
    }
  }, [calculateMaxHealth]);

  const updateCharacter = useCallback(async (updatedData) => {
    if (isUpdating) {
      setError('Please wait, character is being updated...');
      return;
    }

    setIsUpdating(true);
    setError(null);

    if (updateTimeoutRef.current) {
      clearTimeout(updateTimeoutRef.current);
    }

    updateTimeoutRef.current = setTimeout(async () => {
      try {
        const { data } = await character.update(updatedData);
        const maxHealth = calculateMaxHealth(data);
        setCharacterData({
          ...data,
          healthData: {
            currentHealth: data.healthData.currentHealth,
            maxHealth: maxHealth,
            lastHealthUpdate: new Date().toISOString()
          },
          calculatedStats: {
            ...data.calculatedStats,
            healthRegenRate: maxHealth / data.fullRegenTime
          }
        });
      } catch (err) {
        console.error('Error updating character:', err);
        if (err.response && err.response.status === 409) {
          await fetchCharacter();
          setError('Data conflict occurred. The latest data has been loaded.');
        } else {
          setError('Failed to update character data. Please try again.');
        }
      } finally {
        setIsUpdating(false);
      }
    }, 500);
  }, [calculateMaxHealth, fetchCharacter, isUpdating]);

  const equipItem = useCallback(async (charItemId) => {
    try {
      setError(null);
      const { data } = await character.equipItem(charItemId);
      const maxHealth = calculateMaxHealth(data);
      setCharacterData({
        ...data,
        healthData: {
          currentHealth: data.healthData.currentHealth,
          maxHealth: maxHealth,
          lastHealthUpdate: new Date().toISOString()
        },
        calculatedStats: {
          ...data.calculatedStats,
          healthRegenRate: maxHealth / data.fullRegenTime
        }
      });
      return { success: true };
    } catch (err) {
      console.error('Error equipping item:', err);
      setError('Failed to equip item');
      return { success: false, message: 'Failed to equip item' };
    }
  }, [calculateMaxHealth]);

  useEffect(() => {
    fetchCharacter();
    return () => {
      if (updateTimeoutRef.current) {
        clearTimeout(updateTimeoutRef.current);
      }
    };
  }, [fetchCharacter]);

  useEffect(() => {
    if (characterData) {
      healthUpdateInterval.current = setInterval(updateHealth, 1000);
    }
    return () => {
      if (healthUpdateInterval.current) {
        clearInterval(healthUpdateInterval.current);
      }
    };
  }, [characterData, updateHealth]);

  return {
    character: characterData,
    loading,
    error,
    isUpdating,
    updateCharacter,
    equipItem,
    fetchCharacter
  };
};

export default useCharacter;

// Код файла hooks\useCharacterStatus.js:
import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { APP_SERVER_URL } from '../config/config';

const useCharacterStatus = (initialStatus) => {
  const [status, setStatus] = useState(initialStatus || { user: 'idle', auto: null });

  const fetchStatus = useCallback(async () => {
    try {
      const response = await axios.get(`${APP_SERVER_URL}/api/status`, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
      });
      setStatus(response.data.status);
    } catch (error) {
      console.error('Error fetching status:', error);
    }
  }, []);

  const updateStatus = useCallback(async (newStatus) => {
    try {
      const response = await axios.put(`${APP_SERVER_URL}/api/status`, {
        statusType: 'user',
        newStatus
      }, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
      });
      setStatus(response.data.status);
    } catch (error) {
      console.error('Error updating status:', error);
    }
  }, []);

  useEffect(() => {
    fetchStatus();
  }, [fetchStatus]);

  return { status, updateStatus, fetchStatus };
};

export default useCharacterStatus;
