// Внимание! Это собранный код всех файлов server проекта. Обязательно изучи его до конца и прими в работу. При необходимости ты можешь создать новые файлы.

// Далее код файла server.js:
const express = require('express');
const dotenv = require('dotenv');
const cors = require('cors');
const connectDB = require('./config/database');
const authRoutes = require('./routes/authRoutes');
const characterRoutes = require('./routes/characterRoutes');
const gameItemRoutes = require('./routes/gameItemRoutes');
const charItemRoutes = require('./routes/charItemRoutes');

dotenv.config({ path: '.env' });

const app = express();

// Middleware
app.use(express.json());
app.use(cors({
  origin: 'http://localhost:3000',
  credentials: true
}));

// Connect to database
connectDB();

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/character', characterRoutes);
app.use('/api/gameItem', gameItemRoutes);
app.use('/api/charItem', charItemRoutes);

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

// Далее код файла config\database.js:
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log('MongoDB connected');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

module.exports = connectDB;

// Далее код файла controllers\authController.js:
const User = require('../models/User');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

exports.register = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    // Проверяем, существует ли уже пользователь с таким именем или email
    const existingUser = await User.findOne({ $or: [{ username }, { email }] });
    if (existingUser) {
      console.log('Регистрация не удалась: Пользователь уже существует');
      return res.status(400).json({ message: 'Пользователь уже существует' });
    }
    
    // Хешируем пароль
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
    
    // Создаем нового пользователя
    const newUser = new User({
      username,
      email,
      password: hashedPassword,
      hasCharacter: false
    });
    
    await newUser.save();
    console.log('Создан новый пользователь:', newUser._id);
    
    // Генерируем токен
    const token = jwt.sign({ id: newUser._id }, process.env.JWT_SECRET, { expiresIn: '1h' });
    console.log('Токен сгенерирован для нового пользователя');
    
    res.status(201).json({ 
      message: 'Пользователь успешно зарегистрирован', 
      token,
      user: {
        id: newUser._id,
        username: newUser.username,
        email: newUser.email,
        hasCharacter: newUser.hasCharacter
      }
    });
  } catch (error) {
    console.error('Ошибка регистрации:', error);
    res.status(500).json({ message: 'Ошибка сервера', error: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Ищем пользователя
    const user = await User.findOne({ username });
    if (!user) {
      console.log('Вход не удался: Пользователь не найден');
      return res.status(400).json({ message: 'Неверные учетные данные' });
    }
    
    // Проверяем пароль
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      console.log('Вход не удался: Неверный пароль');
      return res.status(400).json({ message: 'Неверные учетные данные' });
    }
    
    // Генерируем токен
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1h' });
    console.log('Вход успешен, токен сгенерирован');
    
    res.json({ 
      token,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role,
        hasCharacter: user.hasCharacter
      }
    });
  } catch (error) {
    res.status(400).json({ message: 'Error logging in', error: error.message });
  }
};

exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    res.json({
      id: user._id,
      username: user.username,
      email: user.email,
      role: user.role,
      hasCharacter: user.hasCharacter
    });
  } catch (error) {
    console.error('Ошибка при получении данных пользователя:', error);
    res.status(500).json({ message: 'Ошибка сервера', error: error.message });
  }
};

exports.makeAdmin = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    user.role = 'admin';
    await user.save();
    
    res.json({
      message: 'User role updated to admin',
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role,
        hasCharacter: user.hasCharacter
      }
    });
  } catch (error) {
    console.error('Error updating user role:', error);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};

// Далее код файла controllers\characterController.js:
const Character = require('../models/Character');
const User = require('../models/User');
const CharItem = require('../models/CharItem');

exports.createCharacter = async (req, res) => {
  try {
    const { nickname, class: characterClass, baseStrength, baseDexterity, baseIntelligence, baseEndurance, baseCharisma } = req.body;
    
    // Проверка распределения очков
    const baseStats = 50; // 10 на каждую характеристику
    const totalStats = baseStrength + baseDexterity + baseIntelligence + baseEndurance + baseCharisma;
    if (totalStats - baseStats > 5) {
      return res.status(400).json({ message: 'Неверное распределение характеристик' });
    }

    // Проверяем, есть ли уже персонаж у пользователя
    const existingCharacter = await Character.findOne({ user: req.user._id });
    if (existingCharacter) {
      return res.status(400).json({ message: 'У пользователя уже есть персонаж' });
    }

    const character = new Character({
      user: req.user._id,
      nickname,
      class: characterClass,
      baseStrength,
      baseDexterity,
      baseIntelligence,
      baseEndurance,
      baseCharisma,
      availablePoints: 5 - (totalStats - baseStats)
    });
    await character.save();

    // Обновляем поле hasCharacter у пользователя
    await User.findByIdAndUpdate(req.user._id, { hasCharacter: true });

    res.status(201).json(character);
  } catch (error) {
    console.error('Ошибка создания персонажа:', error);
    res.status(400).json({ message: 'Ошибка создания персонажа', error: error.message });
  }
};

exports.getCharacter = async (req, res) => {
  try {
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }
    
    const healthData = character.getHealthData();
    const characterData = character.toObject();
    characterData.healthData = healthData;
    characterData.calculatedStats = character.calculatedStats;
    
    res.json(characterData);
  } catch (error) {
    console.error('Ошибка при получении персонажа:', error);
    res.status(400).json({ message: 'Ошибка при получении персонажа', error: error.message });
  }
};

exports.updateCharacter = async (req, res) => {
  try {
    const { baseStrength, baseDexterity, baseIntelligence, baseEndurance, baseCharisma, version } = req.body;
    
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    if (character.version !== version) {
      return res.status(409).json({ message: 'Конфликт версий. Обновите данные и попробуйте снова.' });
    }

    if (character.finalDistribution) {
      return res.status(400).json({ message: 'Распределение очков уже завершено' });
    }

    const newTotalStats = baseStrength + baseDexterity + baseIntelligence + baseEndurance + baseCharisma;
    const oldTotalStats = character.baseStrength + character.baseDexterity + character.baseIntelligence + character.baseEndurance + character.baseCharisma;
    const pointsSpent = newTotalStats - oldTotalStats;

    if (pointsSpent > character.availablePoints || pointsSpent < 0) {
      return res.status(400).json({ message: 'Недопустимое распределение очков' });
    }

    character.baseStrength = baseStrength;
    character.baseDexterity = baseDexterity;
    character.baseIntelligence = baseIntelligence;
    character.baseEndurance = baseEndurance;
    character.baseCharisma = baseCharisma;
    character.availablePoints -= pointsSpent;

    await character.save();
    
    const healthData = character.getHealthData();
    const characterData = character.toObject();
    characterData.healthData = healthData;
    characterData.calculatedStats = character.calculatedStats;

    res.json(characterData);
  } catch (error) {
    console.error('Ошибка обновления персонажа:', error);
    res.status(400).json({ message: 'Ошибка обновления персонажа', error: error.message });
  }
};

exports.addCharItemToInventory = async (req, res) => {
  try {
    const { charItemId } = req.body;
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }
    
    const charItem = await CharItem.findById(charItemId);
    if (!charItem) {
      return res.status(404).json({ message: 'Предмет не найден' });
    }

    const inventoryCharItem = character.inventory.find(i => i.charItem.toString() === charItemId);
    if (inventoryCharItem) {
      inventoryCharItem.quantity += 1;
    } else {
      character.inventory.push({ charItem: charItemId, quantity: 1 });
    }

    await character.save();
    res.json(character);
  } catch (error) {
    console.error('Ошибка добавления предмета в инвентарь:', error);
    res.status(400).json({ message: 'Ошибка добавления предмета в инвентарь', error: error.message });
  }
};

exports.equipCharItem = async (req, res) => {
  try {
    const { charItemId, slot } = req.body;
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    const charItem = await CharItem.findById(charItemId);
    if (!charItem) {
      return res.status(404).json({ message: 'Предмет не найден' });
    }

    if (charItem.slot !== slot) {
      return res.status(400).json({ message: 'Предмет нельзя экипировать в этот слот' });
    }

    // Снимаем текущий предмет, если он есть
    if (character.equipment[slot]) {
      character.inventory.push({ charItem: character.equipment[slot], quantity: 1 });
    }

    // Удаляем предмет из инвентаря и экипируем его
    const inventoryIndex = character.inventory.findIndex(i => i.charItem.toString() === charItemId);
    if (inventoryIndex === -1) {
      return res.status(400).json({ message: 'Предмет не найден в инвентаре' });
    }

    if (character.inventory[inventoryIndex].quantity > 1) {
      character.inventory[inventoryIndex].quantity -= 1;
    } else {
      character.inventory.splice(inventoryIndex, 1);
    }

    character.equipment[slot] = charItemId;

    await character.save();

    const healthData = character.getHealthData();
    const characterData = character.toObject();
    characterData.healthData = healthData;
    characterData.calculatedStats = character.calculatedStats;

    res.json(characterData);
  } catch (error) {
    console.error('Ошибка экипировки предмета:', error);
    res.status(400).json({ message: 'Ошибка экипировки предмета', error: error.message });
  }
};

// Добавим метод для получения данных о здоровье
exports.getHealthData = async (req, res) => {
  try {
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    const healthData = character.getHealthData();
    res.json(healthData);
  } catch (error) {
    console.error('Ошибка при получении данных о здоровье:', error);
    res.status(400).json({ message: 'Ошибка при получении данных о здоровье', error: error.message });
  }
};

// Метод для нанесения урона персонажу
exports.damageCharacter = async (req, res) => {
  try {
    const { damage } = req.body;
    const character = await Character.findOne({ user: req.user._id });
    if (!character) {
      return res.status(404).json({ message: 'Персонаж не найден' });
    }

    const currentHealth = character.getCurrentHealth();
    const newHealth = Math.max(0, currentHealth - damage);
    character.updateHealth(newHealth);

    await character.save();

    const healthData = character.getHealthData();
    res.json(healthData);
  } catch (error) {
    console.error('Ошибка при нанесении урона персонажу:', error);
    res.status(400).json({ message: 'Ошибка при нанесении урона персонажу', error: error.message });
  }
};

module.exports = exports;

// Далее код файла controllers\charItemController.js:
const CharItem = require('../models/CharItem');

exports.createCharItem = async (req, res) => {
  try {
    const charItem = new CharItem(req.body);
    await charItem.save();
    res.status(201).json(charItem);
  } catch (error) {
    res.status(400).json({ message: 'Error creating char item', error: error.message });
  }
};

exports.getAllCharItems = async (req, res) => {
  try {
    const charItems = await CharItem.find();
    res.json(charItems);
  } catch (error) {
    res.status(400).json({ message: 'Error fetching char items', error: error.message });
  }
};

// Далее код файла controllers\gameItemController.js:
const GameItem = require('../models/gameItem');
const Character = require('../models/Character');

exports.createGameItem = async (req, res) => {
  try {
    const gameItem = new GameItem(req.body);
    await gameItem.save();
    res.status(201).json(gameItem);
  } catch (error) {
    res.status(400).json({ message: 'Error creating game item', error: error.message });
  }
};

exports.getAllGameItems = async (req, res) => {
  try {
    const gameItems = await GameItem.find();
    res.json(gameItems);
  } catch (error) {
    res.status(400).json({ message: 'Error fetching game items', error: error.message });
  }
};

exports.getGameItemById = async (req, res) => {
  try {
    const gameItem = await GameItem.findById(req.params.id);
    if (!gameItem) {
      return res.status(404).json({ message: 'Game item not found' });
    }
    res.json(gameItem);
  } catch (error) {
    res.status(400).json({ message: 'Error fetching game item', error: error.message });
  }
};

exports.updateGameItem = async (req, res) => {
  try {
    const gameItem = await GameItem.findByIdAndUpdate(req.params.id, req.body, { new: true });
    if (!gameItem) {
      return res.status(404).json({ message: 'Game item not found' });
    }
    res.json(gameItem);
  } catch (error) {
    res.status(400).json({ message: 'Error updating game item', error: error.message });
  }
};

exports.deleteGameItem = async (req, res) => {
  try {
    const gameItem = await GameItem.findByIdAndDelete(req.params.id);
    if (!gameItem) {
      return res.status(404).json({ message: 'Game item not found' });
    }
    res.json({ message: 'Game item deleted successfully' });
  } catch (error) {
    res.status(400).json({ message: 'Error deleting game item', error: error.message });
  }
};

exports.sendGameItemToCharacter = async (req, res) => {
  try {
    const { gameItemId, characterId } = req.params;

    const gameItem = await GameItem.findById(gameItemId);
    if (!gameItem) {
      return res.status(404).json({ message: 'Game item not found' });
    }
    
    const character = await Character.findById(characterId);
    if (!character) {
      return res.status(404).json({ message: 'Character not found' });
    }
    
    // Добавляем игровой предмет к персонажу
    character.inventory.push({ charItem: gameItem._id, quantity: 1 });
    await character.save();
    
    res.json({ message: 'Game item sent to character successfully', character });
  } catch (error) {
    res.status(400).json({ message: 'Error sending game item', error: error.message });
  }
};

// Далее код файла middlewares\adminMiddleware.js:
// middlewares/adminMiddleware.js
const adminMiddleware = (req, res, next) => {
    if (req.user && req.user.role === 'admin') {
      next();
    } else {
      res.status(403).json({ message: 'Access denied. Admin role required.' });
    }
  };
  
  module.exports = adminMiddleware;

// Далее код файла middlewares\authMiddleware.js:
const jwt = require('jsonwebtoken');
const User = require('../models/User');

const authMiddleware = async (req, res, next) => {
  try {
    const token = req.header('Authorization').replace('Bearer ', '');
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findOne({ _id: decoded.id });

    if (!user) {
      throw new Error();
    }

    req.token = token;
    req.user = user;
    next();
  } catch (error) {
    res.status(401).send({ error: 'Please authenticate.' });
  }
};

module.exports = authMiddleware;

// Далее код файла models\Character.js:
const mongoose = require('mongoose');

const characterSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  nickname: {
    type: String,
    required: true
  },
  class: {
    type: String,
    enum: ['Warrior', 'Mage', 'Archer'],
    required: true
  },
  level: { type: Number, default: 1 },
  experience: { type: Number, default: 0 },
  gold: { type: Number, default: 0 },
  status: {
    type: String,
    enum: ['idle', 'in_battle', 'resting'],
    default: 'idle'
  },

  // Базовые характеристики
  baseStrength: { type: Number, default: 10 },
  baseDexterity: { type: Number, default: 10 },
  baseIntelligence: { type: Number, default: 10 },
  baseEndurance: { type: Number, default: 10 },
  baseCharisma: { type: Number, default: 10 },

  // Здоровье
  health: {
    type: Number,
    default: function () {
      return this.getMaxHealth();
    }
  },
  lastHealthUpdate: { type: Date, default: Date.now },
  fullRegenTimeInSeconds: { type: Number, default: 600 }, // 10 минут по умолчанию

  // Очки характеристик
  availablePoints: { type: Number, default: 5 },

  // Инвентарь
  inventory: [{
    charItem: { type: mongoose.Schema.Types.ObjectId, ref: 'CharItem' },
    quantity: { type: Number, default: 1 }
  }],

  // Экипировка
  equipment: {
    weapon: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' },
    armor: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' },
    helmet: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' },
    shield: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' },
    cloak: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' },
    boots: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' },
    belt: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' },
    accessory: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' },
    banner: { type: mongoose.Schema.Types.ObjectId, ref: 'GameItem' }
  },

  version: { type: Number, default: 0 }
}, { timestamps: true });

// Виртуальное поле для проверки завершения распределения очков
characterSchema.virtual('finalDistribution').get(function () {
  return this.availablePoints === 0;
});

// Метод для получения максимального здоровья
characterSchema.methods.getMaxHealth = function() {
  return 10000 + (this.baseEndurance * 10);
};

// Метод для получения текущего здоровья с учетом регенерации
characterSchema.methods.getCurrentHealth = function() {
  const now = new Date();
  const secondsSinceLastUpdate = Math.max(0, (now - this.lastHealthUpdate) / 1000);
  const regenRate = this.getHealthRegenRate();
  const regenAmount = regenRate * secondsSinceLastUpdate;
  const maxHealth = this.getMaxHealth();
  const newHealth = Math.min(this.health + regenAmount, maxHealth);
  
  return Math.round(newHealth * 100) / 100;
};

// Метод для получения скорости регенерации здоровья
characterSchema.methods.getHealthRegenRate = function() {
  const maxHealth = this.getMaxHealth();
  return maxHealth / this.fullRegenTimeInSeconds;
};

// Метод для обновления здоровья
characterSchema.methods.updateHealth = function (newHealth) {
  this.health = Math.min(newHealth, this.getMaxHealth());
  this.lastHealthUpdate = new Date();
};

// Метод для получения данных о здоровье
characterSchema.methods.getHealthData = function () {
  const currentHealth = this.getCurrentHealth();
  const maxHealth = this.getMaxHealth();
  const regenRate = this.getHealthRegenRate();

  return {
    currentHealth,
    maxHealth,
    regenRate,
    lastUpdate: this.lastHealthUpdate
  };
};

// Виртуальное поле для рассчитываемых характеристик
characterSchema.virtual('calculatedStats').get(function () {
  const maxHealth = this.getMaxHealth();
  return {
    strength: this.baseStrength, // + бонусы от экипировки и навыков
    dexterity: this.baseDexterity, // + бонусы
    intelligence: this.baseIntelligence, // + бонусы
    endurance: this.baseEndurance, // + бонусы
    charisma: this.baseCharisma, // + бонусы
    health: this.getCurrentHealth(),
    maxHealth: maxHealth,
    damage: this.baseStrength * 2, // Пример расчета урона
    armor: this.baseEndurance, // Пример расчета брони
    criticalChance: this.baseDexterity * 0.1, // Пример расчета шанса крита
    criticalDamage: 150 + this.baseStrength, // Пример расчета силы крита
    dodge: this.baseDexterity * 0.2, // Пример расчета уворота
    healthRegen: this.getHealthRegenRate(), // Скорость регенерации здоровья
    counterAttack: this.baseDexterity * 0.5 // Пример расчета шанса контратаки
  };
});

// Метод для получения максимального количества слотов навыков
characterSchema.methods.getMaxSkillSlots = function () {
  return Math.floor(this.level / 5) + 3; // Базовые 3 слота + 1 слот каждые 5 уровней
};

// Пре-сохранение для увеличения версии и обновления здоровья
characterSchema.pre('save', function(next) {
  if (this.isNew) {
    this.health = this.getMaxHealth();
  }
  
  if (this.isModified('baseStrength') ||
      this.isModified('baseDexterity') ||
      this.isModified('baseIntelligence') ||
      this.isModified('baseEndurance') ||
      this.isModified('baseCharisma') ||
      this.isModified('equipment') ||
      this.isModified('inventory')) {
    this.version += 1;
  }
  
  this.updateHealth(this.getCurrentHealth());
  next();
});

module.exports = mongoose.model('Character', characterSchema);

// Далее код файла models\CharItem.js:
const mongoose = require('mongoose');

const charItemSchema = new mongoose.Schema({
  name: { type: String, required: true },
  type: { 
    type: String, 
    enum: ['weapon', 'armor', 'accessory'], 
    required: true 
  },
  slot: { 
    type: String, 
    enum: ['hand', 'body', 'head', 'feet', 'accessory'], 
    required: true 
  },
  stats: {
    strength: { type: Number, default: 0 },
    dexterity: { type: Number, default: 0 },
    intelligence: { type: Number, default: 0 },
    health: { type: Number, default: 0 }
  },
  description: { type: String }
});

module.exports = mongoose.model('CharItem', charItemSchema);

// Далее код файла models\GameItem.js:
const mongoose = require('mongoose');

const gameItemSchema = new mongoose.Schema({
  name: { type: String, required: true },
  type: { 
    type: String, 
    enum: ['weapon', 'armor', 'accessory', 'banner', 'helmet', 'shield', 'cloak', 'belt', 'boots'], 
    required: true 
  },
  rarity: {
    type: String,
    enum: ['common', 'uncommon', 'rare', 'epic', 'legendary'],
    default: 'common'
  },
  minLevel: { type: Number, default: 1 },
  image: { type: String, default: '' },
  stats: {
    strength: { type: Number, default: 0 },
    dexterity: { type: Number, default: 0 },
    intelligence: { type: Number, default: 0 },
    endurance: { type: Number, default: 0 },
    charisma: { type: Number, default: 0 },
    damage: { type: Number, default: 0 },
    armor: { type: Number, default: 0 },
    criticalChance: { type: Number, default: 0 },
    criticalDamage: { type: Number, default: 0 },
    dodge: { type: Number, default: 0 },
    healthRegen: { type: Number, default: 0 },
    health: { type: Number, default: 0 },
    counterAttack: { type: Number, default: 0 }
  }
});

module.exports = mongoose.model('GameItem', gameItemSchema);

// Далее код файла models\User.js:
// models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: { 
    type: String, 
    required: true, 
    unique: true 
  },
  email: { 
    type: String, 
    required: true, 
    unique: true 
  },
  password: { 
    type: String, 
    required: true 
  },
  role: {
    type: String,
    enum: ['player', 'moderator', 'admin'],
    default: 'player'
  },
  hasCharacter: { 
    type: Boolean, 
    default: false 
  }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);

// Далее код файла routes\authRoutes.js:
const express = require('express');
const router = express.Router();
const { register, login, getMe, makeAdmin } = require('../controllers/authController');
const authMiddleware = require('../middlewares/authMiddleware');

router.post('/register', register);
router.post('/login', login);
router.post('/make-admin', authMiddleware, makeAdmin);
router.get('/me', authMiddleware, getMe);


module.exports = router;

// Далее код файла routes\characterRoutes.js:
const express = require('express');
const { 
  createCharacter, 
  getCharacter, 
  updateCharacter, 
  addCharItemToInventory, 
  equipCharItem 
} = require('../controllers/characterController');
const authMiddleware = require('../middlewares/authMiddleware');

const router = express.Router();

router.post('/', authMiddleware, createCharacter);
router.get('/', authMiddleware, getCharacter);
router.put('/', authMiddleware, updateCharacter);
router.post('/inventory', authMiddleware, addCharItemToInventory);
router.post('/equip', authMiddleware, equipCharItem);

module.exports = router;

// Далее код файла routes\charItemRoutes.js:
const express = require('express');
const { createCharItem, getAllCharItems } = require('../controllers/charItemController');
const authMiddleware = require('../middlewares/authMiddleware');

const router = express.Router();

router.post('/', authMiddleware, createCharItem);
router.get('/', authMiddleware, getAllCharItems);

module.exports = router;

// Далее код файла routes\gameItemRoutes.js:
const express = require('express');
const router = express.Router();
const { 
  createGameItem, 
  getAllGameItems, 
  getGameItemById, 
  updateGameItem, 
  deleteGameItem,
  sendGameItemToCharacter
} = require('../controllers/gameItemController');
const authMiddleware = require('../middlewares/authMiddleware');
const adminMiddleware = require('../middlewares/adminMiddleware');

router.post('/', authMiddleware, adminMiddleware, createGameItem);
router.get('/', authMiddleware, getAllGameItems);
router.get('/:id', authMiddleware, getGameItemById);
router.put('/:id', authMiddleware, adminMiddleware, updateGameItem);
router.delete('/:id', authMiddleware, adminMiddleware, deleteGameItem);
router.post('/send/:gameItemId/:characterId', authMiddleware, adminMiddleware, sendGameItemToCharacter);

module.exports = router;

